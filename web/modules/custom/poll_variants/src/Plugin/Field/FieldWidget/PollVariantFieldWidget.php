<?php

namespace Drupal\poll_variants\Plugin\Field\FieldWidget;

use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\ReplaceCommand;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldFilteredMarkup;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Field\WidgetBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Form\OptGroup;
use Drupal\Core\Logger\LoggerChannel;
use Drupal\poll_variants\Plugin\PollVariantsPluginInterface;
use Drupal\poll_variants\Plugin\PollVariantsPluginManager;
use Symfony\Component\DependencyInjection\ContainerInterface;
use function array_combine;
use function array_intersect_assoc;
use function array_intersect_key;
use function array_map;
use function array_merge;
use function array_pop;
use function array_search;
use function array_slice;
use function array_unshift;
use function array_walk_recursive;
use function count;
use function implode;
use function str_replace;
use function t;

/**
 * Plugin implementation of the 'poll_variant_field_widget' widget.
 *
 * @FieldWidget(
 *   id = "poll_variant_field_widget",
 *   module = "poll_variants",
 *   label = @Translation("Poll variant field widget"),
 *   field_types = {
 *     "entity_reference"
 *   }
 * )
 */
class PollVariantFieldWidget extends WidgetBase {

    /** @var LoggerChannel */
    private $logger;

    /** @var \Drupal\poll_variants\Plugin\PollVariantsPluginManager */
    private $pollVariantsManager;

    public function __construct($plugin_id,
                                $plugin_definition,
                                FieldDefinitionInterface $field_definition,
                                array $settings,
                                array $third_party_settings,
                                PollVariantsPluginManager $pollVariantsManager,
                                LoggerChannel $logger) {

        $this->pollVariantsManager = $pollVariantsManager;
        $this->logger = $logger;
        parent::__construct($plugin_id, $plugin_definition, $field_definition, $settings, $third_party_settings);
    }

    public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
        return new static(
            $plugin_id,
            $plugin_definition,
            $configuration['field_definition'],
            $configuration['settings'],
            $configuration['third_party_settings'],
            $container->get('plugin.manager.poll_variants'),
            $container->get('logger.factory')->get('poll_variants')
        );
    }

    public function form(FieldItemListInterface $items, array &$form, FormStateInterface $form_state, $get_delta = NULL) {
        
        $form['#element_validate'][]=[$this,'rebuildForm'];
        
        $field = parent::form($items, $form, $form_state, $get_delta); // TODO: Change the autogenerated stub
        //edit-field-poll-0-inline-entity-form-choice-wrapper
        $values = $this->getWidgetValues($form, $form_state);

        $variant_type = $this->getWidgetPluginType($form, $form_state);
        $plugins_options = $this->getPluginList();

        $html_id = $this->createHtmlId(array_merge(['ajax-selector'], $field['#parents'], ['wrapper']));
        $ajax = [
            'field' => ['callback' => [$this, 'ajaxUpdate'], 'wrapper' => $html_id],
        ];


        $field['#prefix'] = "<div id=\"{$html_id}\">";
        $field['#suffix'] = "</div>";

        $field['variant_type'] = [
            '#type' => 'select',
            '#title' => t('Variant type'),
            '#default_value' => $variant_type,
            '#options' => $plugins_options,
            '#required' => TRUE,
            '#ajax' => $ajax['field'],
            '#weight' => -10,
        ];


        if (!empty($variant_type)) {
            $variant_plugin = $this->getVariantsPlugin($variant_type);
            if ($variant_plugin->hasSettings()) {
                $plugin_settings_form = $variant_plugin->getSettingsForm($values, $ajax, $form, $form_state);
                if (!empty($plugin_settings_form)) {
                    $plugin_settings_form += [
                        '#type' => 'container',
                        '#weight' => -9,
                        '#tree' => TRUE,
                    ];
                }
                $parents = $field['#parents'];
                $parents[] = 'apply_button';
                $plugin_settings_form['apply_button'] = [
                    '#type' => 'submit',
                    '#value' => $this->t('Apply variant settings'),
                    '#name' => $this->createHtmlName($parents),
                    '#ajax' => $ajax['field'],
                ];
                if ($variant_plugin->needValidate()) {
                    $plugin_settings_form['apply_button']['#validate'] = [$this, 'pluginSettingsValidate'];
                }
                $field['settings'] = $plugin_settings_form;
            }else{
                $field['settings']=NULL;
            }

        }
        return $field;
    }

    public function pluginSettingsValidate($form, FormStateInterface $form_state) {
        $variant_type = $this->getWidgetPluginType($form, $form_state);
        if ($variant_type) {
            $plugin = $this->getVariantsPlugin($variant_type);
            $plugin->validateSettings($form, $form_state);
        }
    }

    public function rebuildForm($form, FormStateInterface $form_state) {
        $form_state->setRebuild(TRUE);
    }

    protected function createHtmlId($parents) {
        array_unshift($parents, 'edit');
        return implode('-', array_map(function ($item) {
            return str_replace('_', '-', $item);
        }, $parents));
    }

    protected function createHtmlName($parents) {
        $first = array_shift($parents);
        $path = implode('][', $parents);
        return "{$first}[{$path}]";
    }


    /**
     * AJAX callback to update the widget when the selection changes.
     *
     * @param array $form
     *   The form array.
     * @param \Drupal\Core\Form\FormStateInterface $form_state
     *   The form state.
     *
     * @return \Drupal\Core\Ajax\AjaxResponse
     *   An AJAX response to update the selection.
     */
    public static function ajaxUpdate(array $form, FormStateInterface $form_state) {
        $triggering_element = $form_state->getTriggeringElement();
        $wrapper_id = $triggering_element['#ajax']['wrapper'];
        $parents = $triggering_element['#parents'];
        $parents = array_slice($parents, 0, array_search('choice_wrapper', $parents, TRUE));
        array_unshift($parents, $parents[0]);
        $parents[1] = 'widget';
        $parents[] = 'choice';
        $element = NestedArray::getValue($form, $parents);

        $response = new AjaxResponse();
        $response->addCommand(new ReplaceCommand("#$wrapper_id", $element));


        return $response;
    }


    protected function getCurrentLangcode(FormStateInterface $form_state, FieldItemListInterface $items) {
        return $form_state->get('langcode') ?: $items->getEntity()->language()->getId();
    }

    /**
     * {@inheritdoc}
     */
    public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state) {
        $langcode = $this->getCurrentLangcode($form_state, $items);

        /* @var \Drupal\poll\PollChoiceInterface $choice */
        $choice = $items[$delta]->entity;
        if ($choice) {
            if ($choice->language()->getId() != $langcode && !$choice->hasTranslation($langcode)) {
                $choice->addTranslation($langcode, $choice->toArray());
            }
            $choice = $choice->getTranslation($langcode);
        }

        $is_new = $choice->isNew();

        $element['target_id'] = [
            '#type' => 'value',
            '#value' => $is_new ? NULL : $choice->id(),
        ];
        $element['langcode'] = [
            '#type' => 'value',
            '#value' => $langcode,
        ];

        $element['choice'] = [
            '#markup' => $choice->choice->value,
        ];
        return $element;
    }

    /**
     * @param $plugin_id
     *
     * @return \Drupal\poll_variants\Plugin\PollVariantsPluginInterface
     * @throws \Drupal\Component\Plugin\Exception\PluginException
     */
    protected function getVariantsPlugin($plugin_id): PollVariantsPluginInterface {
        return $this->pollVariantsManager->createInstance($plugin_id);
    }

    protected function getPluginList() {
        $plugin_list = [];
        foreach ($this->pollVariantsManager->getDefinitions() as $plugin_id => $plugin) {
            $plugin_list[$plugin_id] = $plugin['title']->render();
        }
        return $plugin_list;
    }

    private function getWidgetValues(array $form, FormStateInterface $form_state) {
        $field_name = $this->fieldDefinition->getName();
        $parents = $form['#parents'];
        $parents[] = "{$field_name}_wrapper";
        return NestedArray::getValue($form_state->getValues(), $parents);
    }

    private function getWidgetPluginType(array $form, FormStateInterface $form_state) {
        $field_name = $this->fieldDefinition->getName();
        $parents = $form['#parents'];
        $parents[] = "{$field_name}_wrapper";
        $parents[] = 'variant_type';
        return NestedArray::getValue($form_state->getUserInput(), $parents);
    }

    /**
     * Special handling to create form elements for multiple values.
     *
     * Handles generic features for multiple fields:
     * - number of widgets
     * - AHAH-'add more' button
     * - table display and drag-n-drop value reordering
     */
    protected function formMultipleElements(FieldItemListInterface $items, array &$form, FormStateInterface $form_state) {
        $field_name = $this->fieldDefinition->getName();
        $cardinality = $this->fieldDefinition->getFieldStorageDefinition()->getCardinality();
        $description = FieldFilteredMarkup::create(\Drupal::token()->replace($this->fieldDefinition->getDescription()));

        $values = $this->getWidgetValues($form, $form_state);
        $variant_type = $this->getWidgetPluginType($form, $form_state);

        $elements = [];
        if ($variant_type) {
            $plugin = $this->getVariantsPlugin($variant_type);

            if ($plugin->hasSettings()) {
                $settings_fields = $plugin->getSettingsFields();
                $settings = array_intersect_assoc($values['settings'], array_combine($settings_fields, $settings_fields));
                if (count($settings_fields) === count($settings)) {
                    $variants = $plugin->getVariants($settings);
                }
            } else {
                $variants = $plugin->getVariants();
            }

            $max = count($variants);
            $title = $this->fieldDefinition->getLabel();
            foreach ($variants as $delta => $data) {

                // Add a new empty item if it doesn't exist yet at this delta.
                /** @var $choice \Drupal\poll\PollChoiceInterface */
                $item = isset($items[$delta]) ? $items[$delta] : $items->appendItem();
                $choice = $item->entity;
                $choice->setChoice($data['label']);
                $element = [
                    '#title' => $this->t('@title (value @number)', ['@title' => $title, '@number' => $delta + 1]),
                    '#title_display' => 'invisible',
                    '#description' => '',
                ];
                $element = $this->formSingleElement($items, $delta, $element, $form, $form_state);

                if ($element) {

                    $element['_weight'] = [
                        '#type' => 'weight',
                        '#title' => $this->t('Weight for row @number', ['@number' => $delta + 1]),
                        '#title_display' => 'invisible',
                        '#delta' => $max,
                        '#default_value' => $items[$delta]->_weight ?: $delta,
                        '#weight' => 100,
                    ];
                    $elements[$delta] = $element;
                }
            }
        }
        if ($elements) {
            $elements += [
                '#theme' => 'field_multiple_value_form',
                '#field_name' => $field_name,
                '#cardinality' => $cardinality,
                '#cardinality_multiple' => $this->fieldDefinition->getFieldStorageDefinition()->isMultiple(),
                '#required' => $this->fieldDefinition->isRequired(),
                '#title' => $title,
                '#description' => $description,
                '#max_delta' => $max,
            ];
        }
        return $elements;
    }

    /**
     * Returns the array of options for the widget.
     *
     * @param \Drupal\Core\Entity\FieldableEntityInterface $entity
     *   The entity for which to return options.
     *
     * @return array
     *   The array of options for the widget.
     */
    protected function getOptions(FieldableEntityInterface $entity) {
        if (!isset($this->options)) {
            // Limit the settable options for the current user account.
            $options = $this->fieldDefinition
                ->getFieldStorageDefinition()
                ->getOptionsProvider($this->column, $entity)
                ->getSettableOptions(\Drupal::currentUser());

            // Add an empty option if the widget needs one.
            if ($empty_label = $this->getEmptyLabel()) {
                $options = ['_none' => $empty_label] + $options;
            }

            $module_handler = \Drupal::moduleHandler();
            $context = [
                'fieldDefinition' => $this->fieldDefinition,
                'entity' => $entity,
            ];
            $module_handler->alter('options_list', $options, $context);

            array_walk_recursive($options, [$this, 'sanitizeLabel']);

            // Options might be nested ("optgroups"). If the widget does not support
            // nested options, flatten the list.
            //            if (!$this->supportsGroups()) {
            //                $options = OptGroup::flattenOptions($options);
            //            }

            $this->options = $options;
        }
        return $this->options;
    }

    protected function getChoiceTypeOptions() {
        $options = [];

        $entities = \Drupal::entityTypeManager()
            ->getStorage('poll_variant_entity_config')
            ->loadMultiple();
        foreach ($entities as $entity) {
            /** @var $entity \Drupal\poll_variants\Entity\PollVariantEntityConfig */
            $options[$entity->id()] = $entity->label();
        }
        return $options;
    }

    /**
     * Determines selected options from the incoming field values.
     *
     * @param \Drupal\Core\Field\FieldItemListInterface $items
     *   The field values.
     *
     * @return array
     *   The array of corresponding selected options.
     */
    protected function getSelectedOptions(FieldItemListInterface $items) {
        // We need to check against a flat list of options.
        $flat_options = OptGroup::flattenOptions($this->getOptions($items->getEntity()));

        $selected_options = [];
        foreach ($items as $item) {
            $value = $item->{$this->column};
            // Keep the value if it actually is in the list of options (needs to be
            // checked against the flat list).
            if (isset($flat_options[$value])) {
                $selected_options[] = $value;
            }
        }

        return $selected_options;
    }

}
